### 利斯科夫替换原则（LSP）与单一职责原则（SRP）在校园卡管理系统中的应用

#### 一、利斯科夫替换原则（LSP）

**核心定义**：子类必须能够完全替换其父类，且不破坏程序的正确性。即父类出现的地方，子类可以无缝替换，且行为一致。

**校园卡管理系统中的实践**：

1. **用户类型模块设计**
   - **父类**：`User`（定义基础方法如`getUserInfo()`，约定返回包含学号、姓名的JSON）。
   - **子类**：`Student`和`Teacher`继承`User`，扩展各自字段（如`Student`添加"班级"，`Teacher`添加"工号"）。
   - **LSP验证**：在用户信息展示界面调用`getUserInfo()`时，无论传入`Student`还是`Teacher`实例，都能正确输出基础信息，且不会因扩展字段导致系统崩溃。
2. **消费记录模块设计**
   - **父类**：`Transaction`定义`getRecord()`方法，约定返回包含时间、金额的标准化记录。
   - **子类**：`DiningTransaction`和`BookBorrowTransaction`需保持相同返回结构。若`BookBorrowTransaction`子类擅自添加"逾期天数"字段，可能破坏消费统计模块的逻辑。

------

#### 二、单一职责原则（SRP）

**核心定义**：一个类应仅有一个引起变化的原因，即专注于单一功能。

**校园卡管理系统中的实践**：

1. **登录认证模块拆分**
   - **违反SRP的设计**：在`LoginController`中同时处理：
      ✓ 密码验证
      ✓ 登录日志记录
      ✓ 权限初始化
   - 改进后
     - `AuthService`：专责密码比对（SHA-256加密验证）。
     - `LogService`：独立记录登录成功/失败。
     - `RoleService`：单独加载用户权限。
   - **优势**：当需要增加短信验证码功能时，只需修改`AuthService`，不影响其他功能。
2. **数据展示与数据处理分离**
   - **原始问题**：在GUI界面类中直接编写SQL查询语句。
   - SRP改进
     - `DataProvider`类：封装所有数据库查询（如`queryBalance()`）。
     - 界面类仅调用`dataProvider.getBalance(userId)`并显示结果。
   - **效果**：当查询逻辑从SQLite改为API调用时，界面代码完全无需修改。

------

#### 三、项目的应用示例

**场景**：校园卡余额查询功能

1. **LSP应用**：
   - 父类`BalanceQuery`定义`getBalance()`方法，约定返回`{code:200, data:{balance:100.00}}`格式。
   - 子类`StudentBalanceQuery`和`TeacherBalanceQuery`必须保持相同返回结构，即使教师可能有"信用额度"字段，也应通过`data`扩展而非修改顶层结构。
2. **SRP应用**：
   - `BalanceCalculator`：专责余额计算逻辑（如消费累计、充值汇总）。
   - `BalanceDisplay`：独立处理显示格式（如保留2位小数、添加¥符号）。
   - `BalanceCache`：单独管理缓存策略。
   - **变更隔离**：当需要增加余额不足提醒功能时，只需在`BalanceDisplay`中添加逻辑，不影响核心计算。

------

通过这两个原则，系统获得以下收益：

- **可维护性**：修改密码加密方式（如MD5→SHA-256）只需改动1个类。
- **可扩展性**：例如如果新增"实验室门禁"功能时，可继承原有`AccessControl`父类而不影响现有门禁模块。
- **鲁棒性**：所有子类行为符合父类约定，避免出现"教师余额查询导致界面崩溃"等意外问题。